# COMANDO: ANÃLISIS COMPLETO DE CONTEXTO

## ğŸ¯ PropÃ³sito

**TRANSPARENCIA ABSOLUTA DEL CONTEXTO DEL AGENTE**

Este comando existe para proporcionar al usuario visibilidad total y sin filtros del contexto que el agente estÃ¡ utilizando. El usuario necesita entender:

- Â¿QuÃ© informaciÃ³n tiene el agente disponible?
- Â¿CuÃ¡nto espacio ocupa cada parte?
- Â¿Es el contexto adecuado para la tarea actual?
- Â¿Hay informaciÃ³n irrelevante que diluya el foco?
- Â¿EstÃ¡ el agente trabajando con informaciÃ³n Ã³ptima?

El agente debe ser COMPLETAMENTE TRANSPARENTE y revelar TODO el contenido de su contexto actual sin omisiones.

---

## âš ï¸ INSTRUCCIÃ“N CRÃTICA ANTES DE EMPEZAR

**ESTE COMANDO REQUIERE SEGUIR EL FORMATO AL PIE DE LA LETRA.**

ğŸš¨ **PRIORIDAD MÃXIMA:** El formato descrito a continuaciÃ³n NO ES UNA SUGERENCIA, es un CONTRATO ESTRICTO que DEBE cumplirse EXACTAMENTE.

- âŒ NO resumir el formato
- âŒ NO simplificar las secciones
- âŒ NO omitir las barras visuales
- âŒ NO cambiar la estructura
- âœ… SEGUIR el formato EXACTAMENTE como se describe

---

## ğŸ“‹ FORMATO OBLIGATORIO

**NO DESVIARSE del formato bajo NINGUNA circunstancia.**

El anÃ¡lisis SIEMPRE debe seguir EXACTAMENTE este formato:

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ANÃLISIS COMPLETO DEL CONTEXTO DEL AGENTE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š SECCIONES DEL CONTEXTO (orden de apariciÃ³n):

[ENUMERAR TODAS LAS SECCIONES EN EL ORDEN EXACTO QUE APARECEN]

Para cada secciÃ³n:
1. NOMBRE DE LA SECCIÃ“N
   X%
   - DescripciÃ³n breve del contenido
   - Datos clave relevantes

**âš ï¸ IMPORTANTE:** El porcentaje SIEMPRE debe ir en una lÃ­nea nueva debajo del nombre de la secciÃ³n, nunca en la misma lÃ­nea.

Para rules:
- nombre-de-la-rule: DescripciÃ³n de una lÃ­nea o menos

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  OCUPACIÃ“N VISUAL POR SECCIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Nombre secciÃ³n]       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  XX%
[Nombre secciÃ³n]       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  XX%

[ORDENAR DE MAYOR A MENOR PORCENTAJE]
[Usar â–ˆ para parte llena, â–‘ para parte vacÃ­a]
[Total de 32 caracteres para la barra = 100%]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ANÃLISIS CRÃTICO: OVERHEAD vs CONTENIDO ÃšTIL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**ğŸš¨ SECCIÃ“N OBLIGATORIA - NUNCA OMITIR**

OVERHEAD FIJO (infraestructura siempre presente):
- tool_definitions: X%
- system_prompt: X%
- guidelines (citing, communication, tool_calling, etc.): X%
**TOTAL OVERHEAD: X%**

CONTENIDO ÃšTIL (especÃ­fico de la tarea):
- CÃ³digo/archivos del proyecto: X%
- Reglas del workspace: X%
- ConversaciÃ³n relevante: X%
- Datos adicionales: X%
**TOTAL ÃšTIL: X%**

DESPERDICIO DETECTADO:
- DuplicaciÃ³n de datos: X%
- Tool results innecesarios: X%
- Secciones sobredimensionadas: X%
**TOTAL DESPERDICIO: X%**

ğŸ“Š RESUMEN:
- Espacio disponible efectivo: X% (100% - overhead)
- Espacio utilizado eficientemente: X%
- Espacio desperdiciado: X%
- **Eficiencia del contexto: X%** (Ãºtil / disponible)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  EVALUACIÃ“N DEL CONTEXTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[INDICADOR] OVERHEAD FIJO
   [Cuantificar tool_definitions + system_prompt + guidelines]
   [Evaluar si el overhead es razonable para la tarea]
   [Identificar MCP tools no utilizados que ocupan espacio]
   [Calcular porcentaje de overhead vs espacio disponible]

[INDICADOR] DUPLICACIÃ“N DE DATOS **ğŸš¨ CRÃTICO**
   [Detectar el mismo diff apareciendo mÃºltiples veces]
   [Identificar archivos leÃ­dos repetidamente]
   [Verificar tool results duplicados]
   [Cuantificar impacto: X% del contexto es duplicado]
   [SIEMPRE reportar si hay duplicaciÃ³n, aunque sea pequeÃ±a]

[INDICADOR] ADECUACIÃ“N DEL CONTEXTO
   [AnÃ¡lisis detallado]
   [Identificar secciones demasiado largas o escuetas]
   [Verificar si hay demasiados ejemplos o muy pocos]
   [Evaluar si el contexto es apropiado para la tarea actual]

[INDICADOR] REDUNDANCIA
   [AnÃ¡lisis detallado]
   [Identificar rules o conceptos que se repiten]
   [Verificar si hay explicaciones mÃºltiples del mismo concepto]
   [Detectar solapamiento entre secciones]

[INDICADOR] COLISIÃ“N SEMÃNTICA
   [AnÃ¡lisis detallado]
   [Identificar rules de conceptos diferentes pero similares]
   [Detectar contradicciones o ambigÃ¼edades]
   [Evaluar prioridad de reglas en conflicto]

[INDICADOR] LLAMADAS A HERRAMIENTAS (si las hay)
   [AnÃ¡lisis detallado de tool calls presentes en el contexto]
   [Evaluar si el tamaÃ±o de las respuestas es adecuado]
   [Identificar si traen mÃ¡s informaciÃ³n de la necesaria]
   [Verificar si hay tool calls redundantes o duplicados]
   [Comprobar eficiencia en la obtenciÃ³n de informaciÃ³n]
   [Detectar archivos grandes leÃ­dos completos innecesariamente]

[INDICADOR] SECCIONES INESPERADAS **ğŸš¨ SORPRESAS**
   [Identificar secciones que ocupan mÃ¡s espacio del esperado]
   [Detectar datos inesperados en el contexto]
   [Reportar cualquier anomalÃ­a que pueda sorprender al usuario]
   [Ejemplos: project_layout excesivo, conversation inflada, etc.]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

âš ï¸ **RECORDATORIO: Este formato es OBLIGATORIO. No simplificar, no resumir, no cambiar la estructura.**

## ğŸš¦ Sistema de SemÃ¡foro

Usar EXACTAMENTE estos indicadores:

- ğŸŸ¢ Verde: Correcto, sin problemas
- ğŸŸ¡ Amarillo: AtenciÃ³n, puede mejorarse
- ğŸ”´ Rojo: Problema crÃ­tico, requiere correcciÃ³n

## ğŸ“ CÃ¡lculo de Porcentajes

Los porcentajes deben ser **aproximados** pero reflejar la proporciÃ³n real de tokens que ocupa cada secciÃ³n respecto al total del contexto.

## ğŸ” Nivel de Detalle

### Para cada secciÃ³n del contexto:
- **Nombre exacto** de la secciÃ³n
- **Porcentaje aproximado** de ocupaciÃ³n (SIEMPRE en una lÃ­nea nueva debajo del nombre)
- **Contenido clave**: resumen de lo que contiene

**ğŸš¨ FORMATO OBLIGATORIO para porcentajes:**
El porcentaje SIEMPRE debe aparecer en una lÃ­nea nueva debajo del nombre del concepto, nunca en la misma lÃ­nea.

**Ejemplo CORRECTO:**
```
1. **rules - always_applied**
   45%
   - DescripciÃ³n breve del contenido
```

**Ejemplo INCORRECTO:**
```
âŒ 1. **rules - always_applied (45%)** - DescripciÃ³n breve
```

### Para workspace rules (ALWAYS APPLIED) especÃ­ficamente:

**ğŸš¨ REGLA CRÃTICA de descripciÃ³n:**

Para cada regla activa, proporciona:
- **TÃ­tulo/concepto** en negrita que debe expresar en una frase el concepto general de la regla
- **NO listar sus detalles internos**
- **NO enumerar sus contenidos**
- **DescripciÃ³n condensada**: resumen MUY CORTO en una sola frase general de quÃ© trata la regla

**Ejemplo correcto:**
```
**ComposiciÃ³n de clases CSS:**
45%
Uso obligatorio de createClassName, prohibiciÃ³n de funciones auxiliares.

**Patrones de cÃ³digo limpio:**
12%
Mantener baja anidaciÃ³n y alta legibilidad mediante extracciÃ³n de lÃ³gica.
```

**âš ï¸ IMPORTANTE:** El porcentaje SIEMPRE debe ir en una lÃ­nea nueva debajo del tÃ­tulo del concepto en negrita.

**Ejemplo INCORRECTO:**
```
âŒ **Patrones de CSS:** Regla que contiene: rotaciones con transforms, naming conventions (.active, .highlight), tokens vs hardcoded, CSS modules patterns, responsive design mobile first, breakpoints disponibles, patrÃ³n estÃ¡ndar.
```

### Para workspace rules (REQUESTABLE):

Para cada regla disponible bajo demanda, muestra ruta absoluta y descripciÃ³n breve.

**Ejemplo:**
```
component-patterns: /Users/user/project/.cursor/rules/patterns.mdc - Patrones de arquitectura de componentes
testing-guidelines: /Users/user/project/.cursor/rules/testing.mdc - GuÃ­as para escribir tests unitarios
```

### Para archivos adjuntos:
- Ruta del archivo
- NÃºmero de lÃ­neas
- Tipo de contenido

### Para conversaciÃ³n actual:
- NÃºmero de mensajes intercambiados
- Resumen del flujo de la conversaciÃ³n
- Temas principales tratados

### Para llamadas a herramientas (tool calls):
- NÃºmero total de llamadas realizadas
- Tipos de herramientas utilizadas
- TamaÃ±o aproximado de las respuestas
- Eficiencia de las llamadas (si traen info necesaria o excesiva)

## âš™ï¸ Barras de Progreso CLI

Usar caracteres estÃ¡ndar de CLI:
- `â–ˆ` (U+2588) para porciÃ³n llena
- `â–‘` (U+2591) para porciÃ³n vacÃ­a
- Total: 32 caracteres = 100%
- Calcular: `caracteres_llenos = round(porcentaje * 32 / 100)`

## ğŸ¯ Orden de EjecuciÃ³n OBLIGATORIO

**SEGUIR ESTE ORDEN EXACTAMENTE - SIN EXCEPCIONES:**

### Fase 1: Inventario Completo
1. **Analizar TODO el contexto** lÃ­nea por lÃ­nea
2. **Identificar TODAS las secciones** presentes:
   - âœ… tool_definitions (NUNCA omitir)
   - âœ… system_prompt (NUNCA omitir)
   - âœ… guidelines (communication, tool_calling, citing_code, etc.)
   - âœ… user_info, rules, project_layout, git_status
   - âœ… additional_data (DETECTAR DUPLICACIÃ“N)
   - âœ… current_conversation (incluye tool_results)
   - âœ… Cualquier otra secciÃ³n inesperada

3. **Calcular porcentaje aproximado** de cada secciÃ³n
4. **Detectar duplicaciones**:
   - Â¿El mismo diff aparece mÃºltiples veces?
   - Â¿Archivos leÃ­dos repetidamente?
   - Â¿Tool results redundantes?

### Fase 2: ClasificaciÃ³n
5. **Clasificar cada secciÃ³n** en:
   - **OVERHEAD FIJO**: tool_definitions, system_prompt, guidelines
   - **CONTENIDO ÃšTIL**: cÃ³digo, reglas, conversaciÃ³n relevante
   - **DESPERDICIO**: duplicaciones, datos innecesarios

6. **Calcular mÃ©tricas**:
   - % Overhead fijo
   - % Contenido Ãºtil
   - % Desperdicio
   - Eficiencia del contexto (Ãºtil / disponible)

### Fase 3: Reporte Estructurado
7. **Listar secciones** en orden de apariciÃ³n con:
   - Nombre exacto
   - Porcentaje (en lÃ­nea nueva)
   - DescripciÃ³n breve
   - Datos clave

8. **Crear visualizaciÃ³n con barras** (ordenadas por tamaÃ±o) - **NO OMITIR**

9. **AnÃ¡lisis crÃ­tico overhead vs Ãºtil** - **SECCIÃ“N OBLIGATORIA**

10. **Evaluar con sistema de semÃ¡foro** - **TODAS las categorÃ­as:**
    - âœ… Overhead fijo
    - âœ… DuplicaciÃ³n de datos (CRÃTICO)
    - âœ… AdecuaciÃ³n del contexto
    - âœ… Redundancia
    - âœ… ColisiÃ³n semÃ¡ntica
    - âœ… Llamadas a herramientas (si las hay)
    - âœ… Secciones inesperadas (SORPRESAS)

### ğŸš¨ ValidaciÃ³n Final
- [ ] Â¿Se identificaron tool_definitions?
- [ ] Â¿Se identificÃ³ system_prompt?
- [ ] Â¿Se detectaron duplicaciones?
- [ ] Â¿Se calculÃ³ overhead vs Ãºtil?
- [ ] Â¿Se reportaron todas las secciones?
- [ ] Â¿Se crearon las barras visuales?
- [ ] Â¿Se evaluaron TODAS las categorÃ­as del semÃ¡foro?

**Si falta CUALQUIER elemento de la checklist, el anÃ¡lisis estÃ¡ INCOMPLETO.**

## ğŸ“Š Ejemplos Detallados de AnÃ¡lisis de Calidad

**IMPORTANTE:** Antes de completar la evaluaciÃ³n, usa tus tokens de razonamiento para **ULTRATHINK** profundamente sobre cada aspecto. Este anÃ¡lisis es crÃ­tico para debugging y requiere reflexiÃ³n exhaustiva.

### ğŸ”´ OVERHEAD FIJO - Ejemplo de anÃ¡lisis crÃ­tico esperado

**Ejemplo de formato esperado:**
> **Overhead fijo detectado: 38% del contexto**
> - tool_definitions: 18% (incluye ~50 tools, de los cuales Figma/Chrome DevTools (~12%) nunca se usan en este proyecto)
> - system_prompt: 7%
> - guidelines: 13% (citing_code: 5%, communication: 2%, tool_calling: 3%, task_management: 2%, making_code_changes: 1%)
> 
> **AnÃ¡lisis:** El proyecto es un monorepo React/TypeScript sin Figma ni browser testing. Las definiciones de Figma (8 tools) y Chrome DevTools (30 tools) ocupan ~12% del contexto sin aportar valor. **RecomendaciÃ³n:** Este overhead es inevitable en Cursor pero el usuario debe ser consciente de que solo ~62% del contexto estÃ¡ disponible para su proyecto.

### ğŸ”´ DUPLICACIÃ“N CRÃTICA - Ejemplo de anÃ¡lisis esperado

**Ejemplo de formato esperado:**
> **DuplicaciÃ³n masiva detectada: 28% del contexto es duplicado**
> - El diff del branch `add-reading` aparece 3 veces en el contexto:
>   1. En el mensaje inicial del usuario (9%)
>   2. En el segundo mensaje del usuario (9%)
>   3. En el tercer mensaje del usuario (10%)
> - Total desperdicio: 18% del contexto (2 copias redundantes del mismo diff)
> 
> **Archivos leÃ­dos mÃºltiples veces:**
> - `component-architecture.mdc`: LeÃ­do en tool_result #1 (3%) y nuevamente en tool_result #4 (3%)
> - Total desperdicio adicional: 3%
> 
> **IMPACTO TOTAL: 21% del contexto es duplicaciÃ³n pura.** Esto reduce el espacio efectivo de ~62% a ~41%. **Severidad: CRÃTICA - casi la mitad del contexto Ãºtil se pierde por duplicaciÃ³n.**

### ğŸ”´ COLISIÃ“N SEMÃNTICA - Ejemplo de anÃ¡lisis esperado

**Ejemplo de formato esperado:**
> **ContradicciÃ³n detectada:** User Rules establece "Don't use ternaries" (prohibiciÃ³n total) mientras Workspace Rules indica "NUNCA usar ternarios anidados" (solo prohibe anidados). Esta contradicciÃ³n afecta cada condicional simple requiriendo interpretaciÃ³n. 
> 
> **ResoluciÃ³n:** User Rules tiene prioridad jerÃ¡rquica â†’ prohibiciÃ³n total de ternarios. Pero Workspace Rules es mÃ¡s especÃ­fica y razonada â†’ sugiere que la intenciÃ³n real es solo evitar anidaciÃ³n.
> 
> **Severidad: MEDIA** - Genera fricciÃ³n en decisiones de cÃ³digo. El agente debe asumir prohibiciÃ³n total pero reconocer que puede ser excesiva para casos simples.

### ğŸŸ¡ REDUNDANCIA - Ejemplo de anÃ¡lisis esperado

**Ejemplo de formato esperado:**
> **DuplicaciÃ³n identificada en rules:**
> - "Traducciones i18n" y "Traducciones dinÃ¡micas": ~40% de solapamiento
>   - Ambas cubren: useTranslation, namespaces, pluralizaciÃ³n con _one/_other
>   - Ambas reiteran: "SIEMPRE usar i18n", "NUNCA hardcodear strings"
>   - Diferencia: "Traducciones dinÃ¡micas" aÃ±ade Ã©nfasis en parÃ¡metros vs valores fijos
>   - PodrÃ­an consolidarse en "Traducciones i18n completas"
> 
> - "Patrones de cÃ³digo limpio" y "Estructura de componentes React": ~25% de solapamiento
>   - Ambas tratan: organizaciÃ³n de cÃ³digo, legibilidad, extracciÃ³n de lÃ³gica
>   - Diferencia: Una es genÃ©rica, otra especÃ­fica de React
>   - Solapamiento aceptable pero podrÃ­a optimizarse
> 
> **Impacto total:** ~4.5% del contexto es redundancia en rules. Consolidar "Traducciones" ahorrarÃ­a ~3% â†’ espacio Ãºtil de ~65% a ~68%.

### ğŸŸ¢ ADECUACIÃ“N - Ejemplo de anÃ¡lisis esperado

**Ejemplo de formato esperado:**
> **Excesivamente detalladas:**
> - "Estructura del repositorio": 7% del contexto con explicaciÃ³n exhaustiva de monorepo, cada paquete, mise.toml, flujos de trabajo. Incluye 8 ejemplos de comandos cuando 2-3 serÃ­an suficientes. **Reducible ~40%** (de 7% a ~4%).
> - "Mixins disponibles": Lista todos los mixins con ejemplos. PodrÃ­a ser referencia externa. **Reducible ~30%** (de 2% a ~1.5%).
> 
> **Insuficientemente detalladas:**
> - "Navigation": Solo muestra useNavigate vs href. No cubre routing complejo, params, state passing. **Requiere +50%** de contenido con ejemplos de casos comunes.
> 
> **Balance general:** Workspace rules ocupan 38% del contexto con distribuciÃ³n: 55% Ãºtil, 20% redundante, 15% ejemplos excesivos, 10% insuficiente. **OptimizaciÃ³n posible: reducir de 38% a ~28%** consolidando redundancias y balanceando ejemplos.

### ğŸŸ¡ SECCIONES INESPERADAS - Ejemplo de anÃ¡lisis esperado

**Ejemplo de formato esperado:**
> **Sorpresas detectadas que el usuario debe conocer:**
> 
> 1. **project_layout ocupa 18%** - En un monorepo con 3 paquetes, el layout es muy detallado incluyendo conteos de archivos por tipo en cada subdirectorio. En proyectos grandes esto puede crecer hasta 25-30%. **Advertencia:** Considerar si este nivel de detalle es necesario o si un layout resumido serÃ­a suficiente.
> 
> 2. **Tool definitions incluyen 30 tools de Chrome DevTools** (~8% del contexto) que nunca se usan en desarrollo React backend. **Advertencia:** Este es overhead fijo inevitable pero el usuario debe saber que ~8% de su contexto estÃ¡ ocupado por herramientas que no necesita.
> 
> 3. **current_conversation incluye 4 tool_results completos** (~8%) de lecturas de archivos .mdc que ahora estÃ¡n en always_applied rules. **Advertencia:** Posible duplicaciÃ³n - las reglas leÃ­das en tool_results estÃ¡n consumiendo espacio cuando ya estÃ¡n aplicadas automÃ¡ticamente.

## âš ï¸ IMPORTANTE - CUMPLIMIENTO OBLIGATORIO DEL FORMATO

ğŸ”´ **ESTAS REGLAS SON ABSOLUTAMENTE OBLIGATORIAS Y NO NEGOCIABLES** ğŸ”´

- âœ… El anÃ¡lisis SIEMPRE debe usar el formato EXACTO especificado arriba
- âœ… NUNCA inventar un formato alternativo
- âœ… NUNCA omitir secciones del formato (barras visuales, evaluaciones, etc)
- âœ… NUNCA cambiar el orden de las secciones de la plantilla
- âœ… NUNCA omitir ninguna secciÃ³n del contexto
- âœ… Las secciones deben aparecer en el orden EXACTO que tienen en el contexto real
- âœ… Los porcentajes deben sumar aproximadamente 100%
- âœ… El idioma del anÃ¡lisis es CASTELLANO
- âœ… Para rules, usar rutas absolutas en links:
  - Formato: `[/ruta/absoluta/archivo.mdc](/ruta/absoluta/archivo.mdc)`
  - Construir: `{workspace_path}/{ruta_relativa}`

**El formato descrito es SAGRADO. Seguirlo al dedillo es la MÃXIMA PRIORIDAD.**

## ğŸ’¡ Secciones del Contexto - LISTA EXHAUSTIVA OBLIGATORIA

### ğŸš¨ CRÃTICO: NO OMITIR NINGUNA SECCIÃ“N

El agente DEBE identificar y reportar TODAS las secciones presentes en el contexto, incluyendo aquellas que puedan sorprender al usuario por su tamaÃ±o o presencia inesperada.

### ğŸ“‹ Secciones SIEMPRE Presentes (Overhead Fijo)

Estas secciones estÃ¡n SIEMPRE en el contexto y deben ser reportadas OBLIGATORIAMENTE:

#### 1. **tool_definitions** (~15-20%)
**ğŸš¨ NUNCA OMITIR - Es la secciÃ³n mÃ¡s grande del overhead fijo**

Definiciones JSON completas de TODAS las herramientas disponibles:
- **Standard tools** (~8 tools): `codebase_search`, `grep`, `read_file`, `write`, `search_replace`, `run_terminal_cmd`, `delete_file`, `web_search`, `read_lints`, `edit_notebook`, `todo_write`, `list_dir`, `glob_file_search`
- **MCP tools** (variable segÃºn instalaciÃ³n):
  - **Figma** (~8 tools): `get_design_context`, `get_variable_defs`, `get_code_connect_map`, `get_screenshot`, `get_metadata`, `create_design_system_rules`, `get_figjam`
  - **Context7** (~2 tools): `resolve-library-id`, `get-library-docs`
  - **Chrome DevTools** (~30 tools): `click`, `navigate_page`, `take_screenshot`, `evaluate_script`, `fill`, `hover`, etc.
  - **Next DevTools** (~6 tools): `init`, `nextjs_docs`, `nextjs_runtime`, `browser_eval`, `upgrade_nextjs_16`, `enable_cache_components`

Cada tool incluye:
- DescripciÃ³n detallada completa
- Schema JSON con todos los parÃ¡metros
- Enums de valores posibles
- Ejemplos de uso
- Restricciones y validaciones

**âš ï¸ IMPORTANTE:** Aunque nunca uses Figma o Chrome DevTools, sus definiciones ocupan contexto. Esto es overhead fijo que reduce el espacio disponible para cÃ³digo y datos del proyecto.

#### 2. **system_prompt** (~5-8%)
**Instrucciones base del agente:**
- Identidad: "AI coding assistant powered by Claude Sonnet 4.5"
- Rol: "Pair programming with a USER"
- Capabilities: acceso a 1M tokens con fresh context windows automÃ¡ticos
- Instrucciones sobre ambiciÃ³n de tareas
- Budget de tokens

#### 3. **communication_guidelines** (~2-3%)
- Uso de markdown y backticks
- Formato de matemÃ¡ticas
- PolÃ­tica de emojis
- Inline line numbers explanation

#### 4. **tool_calling_guidelines** (~2-3%)
- Reglas sobre cuÃ¡ndo/cÃ³mo usar herramientas
- Maximize parallel tool calls
- No referirse a nombres de herramientas
- Implementar cambios en lugar de solo sugerirlos

#### 5. **making_code_changes_guidelines** (~1-2%)
- Crear archivos de dependencias
- UX/UI best practices
- Evitar hashes largos
- Corregir errores de linter

#### 6. **citing_code_guidelines** (~4-6%)
- Formato CODE REFERENCES para cÃ³digo existente
- Formato MARKDOWN CODE BLOCKS para cÃ³digo nuevo
- Reglas crÃ­ticas de formato
- Ejemplos y contraejemplos

#### 7. **task_management_guidelines** (~1-2%)
- CuÃ¡ndo usar todo_write
- GestiÃ³n de estados de tareas
- Ejemplos de uso correcto

**ğŸ“Š OVERHEAD FIJO TOTAL: ~30-40% del contexto**

Este overhead es FIJO y SIEMPRE presente. Solo queda ~60-70% para:
- CÃ³digo/archivos del proyecto
- ConversaciÃ³n
- Reglas especÃ­ficas
- Datos adicionales

### ğŸ“‹ Secciones Variables (Contenido del Proyecto)

Estas secciones dependen del proyecto y conversaciÃ³n actual:

#### 8. **user_info** (~1-2%)
- OS, shell, workspace path
- Fecha actual
- Preferencias de rutas

#### 9. **rules - agent_requestable** (~2-3%)
- Lista de reglas disponibles bajo demanda
- Rutas y descripciones
- Solo referencias, NO contenido completo

#### 10. **rules - always_applied** (~10-30%)
**ğŸš¨ VARIABLE - Puede ser ENORME**
- Reglas que se aplican automÃ¡ticamente
- Puede incluir 10-20+ reglas
- Cada regla puede ocupar ~1-3% del contexto

#### 11. **user_rules** (~0.5-1%)
- Reglas personalizadas del usuario
- Preferencias especÃ­ficas

#### 12. **project_layout** (~5-15%)
**Estructura de archivos del workspace**
- Puede ser muy grande en monorepos
- Incluye conteos de archivos por tipo

#### 13. **git_status** (~1-3%)
- Branch actual
- Archivos modificados
- Commits pendientes

#### 14. **additional_data** (VARIABLE: 0-50%)
**ğŸš¨ CRÃTICO: Puede incluir datos DUPLICADOS**
- Diffs del branch actual
- Archivos adjuntos
- **DETECTAR DUPLICACIÃ“N:** El mismo diff puede aparecer mÃºltiples veces si el usuario lo incluye en varios mensajes

#### 15. **current_conversation** (~5-20%)
**ğŸš¨ CRECE CON CADA MENSAJE**
- Incluye mensajes del usuario
- Respuestas del agente
- **Tool calls y sus resultados completos**
- Puede crecer masivamente en conversaciones largas

#### 16. **tool_results** (VARIABLE: 0-30%)
**Resultados de tool calls ejecutados:**
- Contenido completo de archivos leÃ­dos
- Resultados de bÃºsquedas
- **DETECTAR DUPLICACIÃ“N:** Si se lee el mismo archivo mÃºltiples veces

#### 17. **websearch_results** (si aplicable: 0-10%)
- Resultados de bÃºsquedas web
- Snippets y URLs

#### 18. **linter_errors** (si aplicable: 0-5%)
- Errores de linting activos
- Warnings del proyecto

### ğŸš¨ Secciones INESPERADAS que Pueden Sorprender

El agente DEBE detectar y reportar con Ã‰NFASIS especial:

1. **DuplicaciÃ³n de datos** (~0-50%)
   - **CRÃTICO:** El mismo diff apareciendo mÃºltiples veces
   - Archivos leÃ­dos repetidamente
   - Resultados de tool calls duplicados
   - **Impacto:** Puede desperdiciar hasta 50% del contexto

2. **Tool results desproporcionados** (~0-40%)
   - Archivos muy grandes leÃ­dos completos
   - Reglas requestables cargadas en conversaciÃ³n anterior y ahora en tool_results
   - BÃºsquedas con resultados excesivos
   - **Impacto:** Pueden diluir el foco del agente

3. **ConversaciÃ³n inflada** (~10-30%)
   - Conversaciones muy largas con contexto acumulado
   - Respuestas previas del agente ocupando mucho espacio
   - **Impacto:** Reduce espacio para nuevos datos

4. **MCP tools no utilizados** (~10-15%)
   - Definiciones de Figma si nunca se usa
   - Chrome DevTools completo si no se necesita
   - **Impacto:** Overhead fijo que no aporta valor

5. **Project layout desproporcionado** (~15-25%)
   - En monorepos muy grandes
   - Con muchos node_modules listados
   - **Impacto:** Puede ser mÃ¡s detallado de lo necesario

## ğŸ”“ Transparencia Absoluta

**El agente NO debe ocultar NADA del contexto.**

Este comando existe para que el usuario pueda:
- Auditar completamente quÃ© informaciÃ³n tiene el agente
- Entender las decisiones del agente basÃ¡ndose en su contexto
- Optimizar el contexto para mejorar el rendimiento
- Detectar problemas de context rot o diluciÃ³n de foco
- Identificar oportunidades de mejora en la ingenierÃ­a del contexto

El agente debe proporcionar:
- **Conteo exacto** de tokens por secciÃ³n (aproximado)
- **DescripciÃ³n completa** de cada secciÃ³n sin omitir detalles
- **AnÃ¡lisis crÃ­tico** sin sesgo positivo artificial
- **IdentificaciÃ³n honesta** de problemas o ineficiencias
- **Recomendaciones concretas** de optimizaciÃ³n cuando aplique

---

## ğŸš¨ CHECKLIST FINAL DE VALIDACIÃ“N

Antes de completar el anÃ¡lisis, el agente DEBE verificar:

### âœ… Secciones Obligatorias Reportadas
- [ ] tool_definitions identificado y cuantificado (~15-20%)
- [ ] system_prompt identificado y cuantificado (~5-8%)
- [ ] guidelines identificadas (citing, communication, tool_calling) (~5-8%)
- [ ] Overhead fijo total calculado (~30-40%)

### âœ… AnÃ¡lisis CrÃ­tico Completado
- [ ] Overhead vs contenido Ãºtil calculado y reportado
- [ ] DuplicaciÃ³n de datos detectada y cuantificada
- [ ] Eficiencia del contexto calculada (Ãºtil / disponible)
- [ ] Todas las secciones listadas en orden de apariciÃ³n
- [ ] Barras visuales creadas (ordenadas por tamaÃ±o)

### âœ… EvaluaciÃ³n con SemÃ¡foro
- [ ] ğŸ”´/ğŸŸ¡/ğŸŸ¢ Overhead fijo
- [ ] ğŸ”´/ğŸŸ¡/ğŸŸ¢ DuplicaciÃ³n de datos (CRÃTICO)
- [ ] ğŸ”´/ğŸŸ¡/ğŸŸ¢ AdecuaciÃ³n del contexto
- [ ] ğŸ”´/ğŸŸ¡/ğŸŸ¢ Redundancia
- [ ] ğŸ”´/ğŸŸ¡/ğŸŸ¢ ColisiÃ³n semÃ¡ntica
- [ ] ğŸ”´/ğŸŸ¡/ğŸŸ¢ Llamadas a herramientas (si aplicable)
- [ ] ğŸ”´/ğŸŸ¡/ğŸŸ¢ Secciones inesperadas

### âœ… Sorpresas y AnomalÃ­as
- [ ] Secciones desproporcionadas identificadas
- [ ] Datos inesperados reportados
- [ ] MCP tools no utilizados detectados
- [ ] Project layout excesivo evaluado
- [ ] ConversaciÃ³n inflada analizada

### ğŸš¨ Si falta CUALQUIER checkmark, el anÃ¡lisis estÃ¡ INCOMPLETO

**El usuario espera transparencia TOTAL. No omitir nada por "simplificaciÃ³n".**

---

## ğŸ’¡ Notas Finales para el Agente

### Mentalidad CrÃ­tica Requerida

Este comando NO es para validar que todo estÃ¡ bien. Es para:
1. **Detectar ineficiencias** que el usuario no puede ver
2. **Cuantificar desperdicio** de contexto
3. **Identificar sorpresas** que afectan el rendimiento
4. **Proporcionar datos** para optimizaciÃ³n

### Sesgo Cero

- âŒ NO minimizar problemas encontrados
- âŒ NO asumir que el contexto es "razonable por defecto"
- âŒ NO omitir secciones por ser "esperadas"
- âœ… REPORTAR todo, especialmente lo inesperado
- âœ… SER CRÃTICO con duplicaciones y desperdicio
- âœ… CUANTIFICAR impacto real de cada problema

### Prioridades

1. **NUNCA omitir tool_definitions** - Es la secciÃ³n mÃ¡s grande del overhead
2. **SIEMPRE detectar duplicaciÃ³n** - Puede consumir 20-50% del contexto
3. **REPORTAR overhead fijo completo** - El usuario debe saber cuÃ¡nto espacio tiene realmente
4. **IDENTIFICAR sorpresas** - Secciones inesperadamente grandes o pequeÃ±as

**Este comando es una herramienta de debugging del contexto. Tratarlo con la misma seriedad que debugging de cÃ³digo.**
