---
description: 
globs: 
alwaysApply: true
---
# D&D 3.5 Character Calculation Library Guide

This is a comprehensive TypeScript library for calculating D&D 3.5 character statistics. The library focuses purely on mathematical calculations and data transformations - **it contains no UI logic or visual components**.

## Core Philosophy & Architecture

### An abstract system with emergent features
Since TTRPG games are made to be played with pen and paper, designers often play around with rules and numbers, making the digitalization of the systems quite abstract. An example of this could be a spell that gives you a bonus to your strength equal to half of your character level. This kind of variable game design is hard to implement without abstract systems, and that is what we've done here.
The goal of this system is to have the systems in place so that most of the game design decisions of designers can be implemented in some way through the combination of said systems. 
That is why we will hardly ever create hardcoded functionalities. We will tend to use general systems for most things so that they can be flexible.

### Functional Separation
The system maintains a strict separation between:
- **Base Data**: Input character data (attributes, race, classes, equipment, etc.)
- **Calculated character sheet**: Derived data (AC, initiative, hit points, attack bonuses, etc.)

### Calculation
The main calculation function ([calculateCharacterSheet.ts](mdc:core/domain/character/calculation/calculateCharacterSheet.ts)) uses a reduce pattern with ordered calculation stages to ensure consistent results.
This function is not deterministic since some formulas could have dice in them, therefore having a random factor, but most of the time
this should not be the case.

### Traceability
Every calculated value includes complete **Source Values** that show:
- Which bonuses were applied
- Which bonuses were ignored due to stacking rules
- The origin of each modifier (item, feat, class feature, etc.)

## Key Data Structures

### Changes - The Foundation of Modifications

Changes are the core mechanism for modifying character statistics. All character modifications flow through the change system.

#### BaseChange Structure
```typescript
// From changes.ts
type BaseChange = {
  formula: Formula;           // Mathematical expression
  bonusTypeId: BonusTypes;   // Type of bonus (affects stacking)
  type: ChangeTypes;         // What stat this affects
  conditions?: Condition[];   // When this change applies
}
```

#### Change Types
The system supports multiple change types as defined in [changes.ts](mdc:core/domain/character/baseData/changes.ts):

```typescript
enum ChangeTypes {
  ABILITY_SCORE = "ABILITY_SCORE",     // STR, DEX, CON, etc.
  AC = "AC",                           // Armor Class
  SAVING_THROW = "SAVING_THROW",       // Fort, Ref, Will
  SKILL = "SKILL",                     // Individual skills
  BAB = "BAB",                         // Base Attack Bonus
  INITIATIVE = "INITIATIVE",           // Initiative modifier
  SPEED = "SPEED",                     // Movement speeds
  ATTACK_ROLLS = "ATTACK_ROLLS",       // Attack roll bonuses
  DAMAGE = "DAMAGE",                   // Damage bonuses
  SIZE = "SIZE",                       // Creature size
  // ... and more
}
```

#### Example Changes
```typescript
// Strength enhancement from magic item
const strengthBoost: AbilityScoreChange = {
  type: 'ABILITY_SCORE',
  abilityUniqueId: 'strength',
  bonusTypeId: 'ENHANCEMENT',
  formula: { expression: '4' }
}

// Initiative bonus from Improved Initiative feat
const improvedInitiative: InitiativeChange = {
  type: 'INITIATIVE',
  bonusTypeId: 'UNTYPED',
  formula: { expression: '4' }
}

// Skill bonus with variable reference
const skillBonus: SingleSkillChange = {
  type: 'SKILL',
  skillUniqueId: 'acrobatics',
  bonusTypeId: 'COMPETENCE',
  formula: { expression: '@ability.dexterity.modifier + 2' }
}
```

### Contextual Changes - Situational Modifications

Contextual changes represent bonuses that only apply in specific situations, as defined in [contextualChange.ts](mdc:core/domain/character/baseData/contextualChange.ts). These can be simple toggles or complex modifications with user-configurable variables.

Right now, only attack contextual changes are implemented, and they apply only on attacks.

```typescript
type BaseContextualChange = {
  name: string;
  type: ContextType;
  variables: ContextualVariable[];  // User-configurable parameters
  optional: boolean;                // Can be toggled on/off
  available: boolean;              // Prerequisites met
}

// Example: Simple contextual change (flanking bonus)
const flanking: AttackContextualChange = {
  type: 'attack',
  name: 'Flanking',
  appliesTo: 'melee',
  available: true,
  optional: true,
  variables: [],
  changes: [{
    attackType: 'melee',
    type: 'ATTACK_ROLLS',
    bonusTypeId: 'UNTYPED',
    formula: { expression: '2' }
  }]
}
```

#### Variables in Contextual Changes

Contextual changes can include **variables** that users can manipulate, making them highly flexible. Variables are defined as ranges with min/max values and become available within the change formulas.

```typescript
// Variable definition from variable.ts
type ContextualVariable = {
  name: string;          // Display name
  identifier: string;    // Reference name in formulas
  min: number;          // Minimum allowed value
  max: number;          // Maximum allowed value
}

type ResolvedContextualVariable = ContextualVariable & {
  value: number;        // User-selected value
}
```

#### Example: Power Attack with Variables

```typescript
const powerAttack: AttackContextualChange = {
  type: 'attack',
  name: 'Power Attack',
  appliesTo: 'melee',
  available: true,
  optional: true,
  variables: [
    {
      name: 'Power Attack Points',
      identifier: 'powerAttackPoints',
      min: 1,
      max: 5  // Could be calculated based on BAB
    }
  ],
  changes: [
    {
      attackType: 'melee',
      type: 'ATTACK_ROLLS',
      bonusTypeId: 'UNTYPED',
      formula: { expression: '-@powerAttackPoints' }  // Penalty to attack
    },
    {
      attackType: 'melee', 
      type: 'DAMAGE',
      bonusTypeId: 'UNTYPED',
      formula: { expression: '@powerAttackPoints * 2' }  // Bonus to damage
    }
  ]
}
```

#### Variable Resolution Process

1. **Definition**: Variables are defined in the contextual change with min/max bounds
2. **User Input**: The UI allows users to set values within those bounds
3. **Resolution**: Variables are resolved to specific values during calculation
4. **Substitution**: Variable identifiers (like `@powerAttackPoints`) are replaced with actual values in formulas
5. **Calculation**: The modified formulas are evaluated normally

```typescript
// From getVariablesSubstitutionExpression.ts
const getVariablesSubstitutionExpression = (
  variables: ResolvedContextualVariable[]
): SubstitutionExpressions => {
  const substitutionExpressions: SubstitutionExpressions = {};
  
  variables.forEach((variable) => {
    substitutionExpressions[variable.identifier] = {
      expression: variable.value.toString(),
    };
  });
  
  return substitutionExpressions;
};
```

#### Complex Variable Examples

Variables can reference other character stats and support complex expressions:

```typescript
// Spell-like ability with caster level scaling
const spellStrike: AttackContextualChange = {
  name: 'Spell Strike',
  variables: [
    {
      name: 'Spell Level',
      identifier: 'spellLevel',
      min: 1,
      max: 9
    }
  ],
  changes: [{
    type: 'DAMAGE',
    formula: { 
      expression: '@spellLevel d6 + @ability.intelligence.modifier' 
    }
  }]
}

// Combat expertise with skill synergy
const combatExpertise: AttackContextualChange = {
  name: 'Combat Expertise',
  variables: [
    {
      name: 'Attack Penalty',
      identifier: 'expertisePenalty',
      min: 1,
      max: 5
    }
  ],
  changes: [
    {
      type: 'ATTACK_ROLLS',
      formula: { expression: '-@expertisePenalty' }
    },
    {
      type: 'AC',
      formula: { expression: '@expertisePenalty' }
    }
  ]
}
```

This variable system allows for complex, user-controlled modifications that accurately model D&D 3.5's tactical combat options while maintaining the library's deterministic calculation approach.

### Bonus Types & Stacking Rules

The system implements D&D 3.5 bonus stacking rules through [bonus types](mdc:core/domain/character/baseData/changes.ts):

```typescript
type BonusType = {
  name: string;
  uniqueId: string;
  stacksWithSelf: boolean;  // Key stacking property
}

// Examples of stacking behavior
const BonusTypesValues = {
  ENHANCEMENT: { stacksWithSelf: false },  // Only highest applies
  UNTYPED: { stacksWithSelf: true },       // All stack
  DODGE: { stacksWithSelf: true },         // All stack
  MORALE: { stacksWithSelf: false },       // Only highest applies
  // ...
}
```

## Formula System

Formulas are mathematical expressions that support dice rolls, variables, and functions. They are used throughout the library for calculating bonuses, damage, scaling effects, and more.

### Basic Formula Structure
```typescript
type Formula = {
  expression: string;                    // Mathematical expression
  substitutionData?: SubstitutionData;   // Variable definitions
  extraData?: Record<string, any>;       // Additional metadata
}

// Examples
{ expression: '1d8 + @ability.strength.modifier' }
{ expression: '@powerAttackPoints * 2' }
{ expression: 'floor(@level / 3)' }
```

### Key Capabilities
- **Basic Math**: `+`, `-`, `*`, `/`, parentheses
- **Dice Notation**: `1d6`, `3d6kh2`, `(@level)d4`
- **Variables**: `@ability.strength.modifier`, `@powerAttackPoints`
- **Functions**: `min()`, `max()`, `floor()`, `ceil()`

### Important Limitations
- **No conditional logic**: No ternary operators or if/else statements
- **No comparisons**: Use Change conditions instead of `@level > 10`
- **Mathematical only**: No string operations or programming constructs

> **ðŸ“– For complete formula reference**: See [formula-system.mdc](mdc:.cursor/rules/formula-system.mdc) for detailed syntax, examples, and limitations.

## Character Data Flow

### 1. Base Data Structure
[CharacterBaseData](mdc:core/domain/character/baseData/character.ts) contains all input data:

```typescript
type CharacterBaseData = {
  name: string;
  baseAbilityData: BaseAbilitiesData;    // STR, DEX, CON, etc.
  classes: CharacterClass[];             // Class levels
  race?: Race;                           // Character race
  equipment: Equipment;                  // Items and gear
  feats: Feat[];                        // Selected feats
  buffs: Buff[];                        // Active spell effects
  specialFeatures?: SpecialFeature[];   // Custom abilities
  // ... more fields
}
```

### 2. Calculation Pipeline
The main calculation happens in [calculateCharacterSheet.ts](mdc:core/domain/character/calculation/calculateCharacterSheet.ts):

```typescript
const calculationFunctions = [
  getCalculatedSize,           // Size category first (affects many things)
  getCalculatedAbilityScores, // Ability scores (foundation for many calculations)
  getCalculatedInitiative,    // Initiative
  getCalculatedHitPoints,     // Hit points
  getCalculatedBaseAttackBonus, // BAB
  getCalculatedSavingThrows,  // Saves
  getCalculatedArmorClass,    // AC
  getCalculatedSkills,        // Skills
];
```

Each function:
1. Takes current character data and substitution index
2. Applies relevant changes 
3. Returns updated character sheet fields and new index values
4. Passes results to next function in chain

### 3. Change Compilation
Before calculation, all changes are gathered from various sources:

```typescript
// From compileCharacterChanges.ts
function compileContextualizedChanges(baseData: CharacterBaseData) {
  const changes = [
    ...compileRaceChanges(baseData),      // Racial bonuses
    ...compileClassChanges(baseData),     // Class features
    ...compileFeatChanges(baseData),      // Feat bonuses
    ...compileItemChanges(baseData),      // Equipment bonuses
    ...compileBuffChanges(baseData),      // Active spells/effects
  ];
  return changes;
}
```

### 4. Source Calculation
Each change becomes a [Source](mdc:core/domain/character/calculatedSheet/sources.ts) with full traceability:

```typescript
type Source<T extends Change> = T & {
  totalValue: number;        // Calculated result
  unmetConditions?: boolean; // Whether conditions failed
  // ... original change data preserved
}
```

## Character Features & Origins

### Class Features
Classes provide features through levels, defined in class data:

```typescript
// Example fighter feature
const extraFighterFeat: ClassFeature = {
  uniqueId: 'extraFighterFeat',
  name: 'Extra Fighter Feat',
  description: 'Select an extra feat from the fighter pool.',
  specialChanges: [{
    type: 'EXTRA_FEAT_SELECTION',
    featPoolId: 'fighterFeatPool',
    amount: 1
  }]
}
```

### Racial Features
Races provide inherent bonuses and abilities:

```typescript
// Example elf racial bonuses
const elf: Race = {
  uniqueId: 'elf',
  changes: [
    { type: 'ABILITY_SCORE', abilityUniqueId: 'dexterity', bonusTypeId: 'RACIAL', formula: { expression: '2' }},
    { type: 'ABILITY_SCORE', abilityUniqueId: 'constitution', bonusTypeId: 'RACIAL', formula: { expression: '-2' }},
    { type: 'SKILL', skillUniqueId: 'listen', bonusTypeId: 'RACIAL', formula: { expression: '2' }}
  ]
}
```

### Equipment Integration
Items provide changes when equipped/wielded:

```typescript
type EquippableItem = {
  equipped: boolean;
  equippedChanges: Change[];        // Applied when equipped
  wieldedChanges?: Change[];        // Applied when wielded (weapons)
  equippedContextChanges?: ContextualChange[]; // Situational bonuses
}
```

## Source Values & Stacking

### Source Value Calculation
The [sumSources.ts](mdc:core/domain/character/calculation/sources/sumSources.ts) system handles bonus stacking:
Source values are a fundamental part of the system, as most calculated values will have a SourceValues array that
displays the composition of the final result.
Source values have a "relevant" field that say wether the value has been applied (given the stacking rules)

```typescript
function getSourceValuesByType(sources: Source[]): SourceValuesByType {
  // Group sources by bonus type
  // Apply stacking rules based on BonusType.stacksWithSelf
  // Mark which bonuses are actually applied vs. superseded
}
```

### Example Source Value Output
```typescript
// AC calculation result might show:
{
  total: 18,
  sourceValues: [
    { value: 10, bonusType: 'BASE', relevant: true, name: 'Base AC' },
    { value: 4, bonusType: 'ARMOR', relevant: true, name: 'Chain Mail' },
    { value: 2, bonusType: 'DEXTERITY', relevant: true, name: 'Dex Modifier' },
    { value: 2, bonusType: 'DEFLECTION', relevant: true, name: 'Ring of Protection' },
    { value: 1, bonusType: 'DEFLECTION', relevant: false, name: 'Lesser Ring' } // Superseded
  ]
}
```

## Special Systems

### Attack Calculations
Attack data gets special handling after main calculation:

```typescript
characterSheet.attackData = getCalculatedAttackData(
  characterSheet,
  characterChanges.attackChanges,
  characterContextualChanges,
  valuesIndex
);
```

This produces weapon attacks with:
- Attack bonus calculations
- Damage formulas (normal and critical)
- Available contextual modifications

### Special Changes
Some changes require custom logic beyond simple formulas:

```typescript
enum SpecialChangeTypes {
  EXTRA_FEAT_SELECTION = 'EXTRA_FEAT_SELECTION',
  NATURAL_WEAPON = 'NATURAL_WEAPON',
  SPELL_RESISTANCE = 'SPELL_RESISTANCE',
  // ... others requiring special handling
}
```

## Usage Patterns

### Basic Character Creation
```typescript
import { calculateCharacterSheet } from './core/domain/character/calculation/calculateCharacterSheet';

const characterData: CharacterBaseData = {
  // ... character definition
};

const characterSheet = calculateCharacterSheet(characterData);
// characterSheet now contains all calculated values with full source tracking
```

### Accessing Calculated Values
```typescript
// Get final AC value
const totalAC = characterSheet.armorClass.totalValue;

// Get AC breakdown
const acSources = characterSheet.armorClass.sourceValues;
acSources.forEach(source => {
  console.log(`${source.name}: ${source.value} (${source.bonusType})`);
});
```

### Working with Formulas
```typescript
// Variable substitution happens automatically during calculation
const formula: Formula = {
  expression: '@ability.strength.modifier + @bab.total',
  // Variables resolved from current character state
};
```

## Key Files Reference

- [changes.ts](mdc:core/domain/character/baseData/changes.ts) - Change types and bonus stacking rules
- [contextualChange.ts](mdc:core/domain/character/baseData/contextualChange.ts) - Situational modifications
- [calculateCharacterSheet.ts](mdc:core/domain/character/calculation/calculateCharacterSheet.ts) - Main calculation pipeline
- [formula.ts](mdc:core/domain/formulae/formula.ts) - Formula system and variable substitution
- [character.ts](mdc:core/domain/character/baseData/character.ts) - Base character data structure
- [sources.ts](mdc:core/domain/character/calculatedSheet/sources.ts) - Source value tracking
- [sumSources.ts](mdc:core/domain/character/calculation/sources/sumSources.ts) - Bonus stacking logic

This library provides a complete, auditable calculation engine for D&D 3.5 characters with full support for the complex bonus stacking and conditional modification rules of the system.
